# exploits/cve_lookup.py

import aiohttp
import asyncio
import logging
from typing import List, Dict, Optional
import json

NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
VULNERS_API_SEARCH = "https://vulners.com/api/v3/search/lucene/"

# Basic cache for API results to avoid redundant queries
CACHE = {}

async def query_nvd_api(session: aiohttp.ClientSession, product: str, version: Optional[str]=None) -> List[Dict]:
    key = f"nvd-{product}-{version}"
    if key in CACHE:
        return CACHE[key]

    query = f"{product} {version}" if version else product
    params = {"query": query}
    try:
        async with session.get(NVD_API_URL, params=params) as resp:
            data = await resp.json()
            CACHE[key] = data.get("vulnerabilities", [])
            return CACHE[key]
    except Exception as e:
        logging.error(f"[CVE-LOOKUP] NVD query failed for {query}: {e}")
        return []

async def query_vulners_api(session: aiohttp.ClientSession, product: str, version: Optional[str] = None) -> List[Dict]:
    key = f"vulners-{product}-{version}"
    if key in CACHE:
        return CACHE[key]

    query = f"{product} {version}" if version else product
    payload = {"query": query}
    try:
        async with session.post(VULNERS_API_SEARCH, json=payload) as resp:
            data = await resp.json()
            results = data.get("data", {}).get("search", [])
            CACHE[key] = results
            return results
    except Exception as e:
        logging.error(f"[CVE-LOOKUP] Vulners query failed for {query}: {e}")
        return []

def extract_version_info(banner: str) -> Optional[Dict[str, str]]:
    # This basic example assumes banners like "Apache/2.4.49" or "nginx 1.21.3"
    import re
    match = re.search(r"(\w+)[/ ]([\d\.]+)", banner)
    if match:
        return {"product": match.group(1), "version": match.group(2)}
    return None

async def lookup_cves(target_info: List[Dict[str, str]]) -> List[Dict]:
    async with aiohttp.ClientSession() as session:
        tasks = []
        for item in target_info:
            prod = item.get("product")
            ver = item.get("version")
            if prod:
                # Query both NVD and Vulners concurrently
                tasks.append(asyncio.gather(
                    query_nvd_api(session, prod, ver),
                    query_vulners_api(session, prod, ver)
                ))
        all_cve_results = await asyncio.gather(*tasks)
    combined_results = []
    for nvd_res, vulners_res in all_cve_results:
        combined_results.extend(nvd_res)
        combined_results.extend(vulners_res)
    return combined_results

def score_and_sort_cves(cves: List[Dict]) -> List[Dict]:
    # Basic scoring - prioritize CVEs with Critical or High severity
    def severity_score(cve):
        base_score = 0
        sev = cve.get("vulnerability", {}).get("cvssMetricV2", [{}])[0].get("baseSeverity", "")
        if sev == "CRITICAL":
            base_score = 3
        elif sev == "HIGH":
            base_score = 2
        elif sev == "MEDIUM":
            base_score = 1
        return base_score
    return sorted(cves, key=severity_score, reverse=True)

async def run_cve_lookup(target_banners: List[str]) -> List[Dict]:
    # Parse banners to extract product/version info
    target_info = []
    for banner in target_banners:
        info = extract_version_info(banner)
        if info:
            target_info.append(info)

    cve_results = await lookup_cves(target_info)
    sorted_results = score_and_sort_cves(cve_results)

    logging.info(f"[CVE-LOOKUP] Found {len(sorted_results)} CVEs for target products")
    return sorted_results

# Optional: function to write CVE results to JSON
def save_cve_results(cve_results: List[Dict], path: str):
    with open(path, 'w') as f:
        json.dump(cve_results, f, indent=2)
